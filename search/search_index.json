{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Enigma Cipher","text":"<p><code>EnigmaCipher</code> is a package that allows you to cipher (encode and/or decode) texts by using the Enigma Machine's logic.</p>"},{"location":"#why-to-use-enigmacipher-to-cipher-texts","title":"Why to use EnigmaCipher to cipher texts","text":"<ul> <li>Easy to use: The instance only needs to know the text to cipher and will return a text.</li> <li>No reinitialization: After ciphering a text, the instance can be used again to decode texts encoded with the same configuration.</li> <li>Infinite configurations: The cipher can be set on multiple configurations which deviate from the historical machine. For example, with six rotors (instead of three) or with every single component randomly initialized.</li> <li>Digits ciphering: In difference to the original machine, this package also allows ciphering digits.</li> </ul>"},{"location":"#setup","title":"Setup","text":"<p>Requirements</p> <ul> <li>Python 3.8 or higher</li> </ul> <p>Installation</p> <p>The package's latest release can be installed via pip:</p> <pre><code>pip install enigma-cipher\n</code></pre> <p>If you wish to work with the latest unreleased changes, install the 'develop' branch:</p> <pre><code>pip install git+https://github.com/Jtachan/enigma_cipher.git@develop\n</code></pre>"},{"location":"#index","title":"Index","text":"<ul> <li>Getting started</li> <li>Components</li> <li>Plug Board</li> <li>Rotor</li> <li>Reflector</li> <li>Enigma Machine</li> </ul>"},{"location":"components/","title":"How it works","text":""},{"location":"components/#about-the-real-enigma-machine","title":"About the real enigma machine","text":"<p>The original enigma machine worked through an electrical pathway, defined by its components, which would scramble the signal for each letter. When a letter was pressed, the signal would travel through the plugboard, then through three rotors and finally through the reflector.  From the reflector, the signal would travel back through the rotors to the lamp, lighting up a letter.</p> <p>After the letter was pressed, one or multiple rotors would step up, changing their position and the electrical pathway which connect all the letters. This means that the same letter pressed twice consecutively would have two different outcomes.</p> <p></p> <p>More about the real enigma machine at its Wikipedia page.</p>"},{"location":"components/#components","title":"Components","text":"<p>Here is explained the behavior of the different components that create an enigma machine.</p>"},{"location":"components/#plugboard","title":"Plugboard","text":"<p>The plugboard (or Steckerbett in German) allows wiring letters in pairs by a manual configuration from the operator. In other words, the operator could choose two configurations for each letter:</p> <ul> <li>Not wired. In this case, if this letter was pressed (for example, the letter \"A\"), the signal sent to the next component would correspond still to the letter \"A\".</li> <li>Wired to another letter. For this, if \"A\" was wired to \"T\" means that if \"A\" is pressed, the signal \"T\" is given to the next component. Consequentially, when \"T\" was pressed, the signal \"A\" was communicated.</li> </ul> <p>The plugboard allows creating a first layer of codification in which not all letters need to be connected.</p>"},{"location":"components/#rotors","title":"Rotors","text":"<p>Rotors connect two letters, which differs depending on the situation the rotor is in. The position of each rotor shows the distance to connect the next letter.</p> <p>These are some examples of the behavior:</p> Rotor's position Incoming signal Outgoing signal 0 \"A\" \"A\" 1 \"A\" \"B\" 5 \"A\" \"F\" 14 \"S\" \"G\" <p>Each time a letter is computed by the machine, the first rotor steps up. When the rotor has done a full rotation, the next rotor steps up. By so, the encoding of each letter changes every time one or more rotors step up.</p> <p>While the original enigma machine was composed of three rotors, the <code>EnigmaMachine</code> package allows using as many or few rotors as desired.</p>"},{"location":"components/#reflector","title":"Reflector","text":"<p>The reflector is the component that allows an encoded message to be decoded by a machine with the same configuration. This component has a static connection of letters by pairs, just like the plugboard, where all letters are connected.</p> <p>The main differences of this component are:</p> <ul> <li>The connexions among the letters won't change through the ciphering of the text.</li> <li>The connexions cannot be changed manually.</li> </ul> <p>By defining these static connexions, each configuration routes the same two keys at one state, allowing the decoding of messages. When a key is pressed, the signal travels from the plugboard through the rotors up to the reflector. At this point, the signal travels back through the rotors (in inverse order) to the lamp, which is the same level as the plugboard.</p> <p>Taking the picture at the top of the page, imagine the rotors will not ever move. This means every time the letter \"A\" is pressed, the outcome is the letter \"G\". In other words, \"A\" is directly connected to \"G\". Therefore, when \"G\" is pressed, the letter \"A\" is to be the outcome.</p> <p>This behavior is the one that the machine experiences to cipher a text, as the rotors will update their state when the finger is lifted from the key.</p>"},{"location":"components/#package-differences","title":"Package differences","text":"<p>The installable package <code>enigma-cipher</code> bases its whole logic into mimicking how the original enigma machine worked. However, the package allows using that logic with a few differences (if desired):</p> <ul> <li>Number of rotors: While the original enigma machine worked with three rotors. <code>enigma-cipher</code> allows setting up a machine with any number of rotors.</li> <li>Using digits: The original machine could encode only letters. While that behaviour is still available in the package, it is possible to set the element to also cipher digits.</li> </ul>"},{"location":"enigma_machine/","title":"Enigma Machine","text":"<p>The <code>EnigmaMachine</code> allows to create a python instance to cipher texts. It has to be composed by three parts: the <code>PlugBoard</code>, the <code>Rotor</code> and the <code>Reflector</code>. The settings of all three parts are defined as the machine's configuration.</p> <p>The <code>EnigmaMachine</code> class can be imported directly from the <code>enigma_cipher</code> package:</p> <pre><code>from enigma_cipher import EnigmaMachine\n</code></pre>"},{"location":"enigma_machine/#enigmamachineplugboard-rotors-reflector-reset_after_cipheringtrue","title":"<code>EnigmaMachine(plugboard, rotors, reflector, reset_after_ciphering=True)</code>","text":"<p>Constructor of the <code>EnigmaMachine</code> cipher. All specified components (plugboard, rotors and reflector) but have defined the same <code>include_digits</code> choice.</p> <p>Parameters</p> <ul> <li>plugboard <code>PlugBoard</code>:Component of the <code>PlugBoard</code>. It specifies the mapping among all the keys at the input/output level.</li> <li>rotors <code>Sequence of Rotor</code>:Initialized <code>Rotor</code> instances in a sequence. While the historic enigma machine contained only three rotors, the <code>EnigmaMachine</code> class can work with as many or few as desired.</li> <li>reflector <code>Reflector</code>:Component of the <code>Reflector</code>.</li> <li>reset_after_ciphering <code>bool</code> (default = True):Flag that controls if the machine should reset to the initial configuration after ciphering a text.</li> </ul>"},{"location":"enigma_machine/#enigmamachinecipher_texttext","title":"<code>EnigmaMachine.cipher_text(text)</code>","text":"<p>Proceeds to cipher a given text. Ciphering will decode an encoded text if the machine has the same configuration as the initial machine that encoded the text.</p> <p>Parameters</p> <ul> <li>text <code>str</code>: Message to cipher (encode or decode) with the current configuration.</li> </ul> <p>Returns</p> <ul> <li><code>str</code>:The ciphered text.</li> </ul>"},{"location":"enigma_machine/#enigmamachineexport_configuration_to_json_fileoutput_path-forcefalse","title":"<code>EnigmaMachine.export_configuration_to_json_file(output_path, force=False)</code>","text":"<p>Export the machine configuration to a '.json' file.</p> <p>Parameters</p> <ul> <li>output_path <code>str</code>:Path to the file to contain the configuration. Values as \"path/to/file\" will create a file \"path/to/file.json\".</li> <li>force <code>bool</code> (default = False):If True, allows overwriting existing output files. Otherwise, raises an error if the file already exists.</li> </ul>"},{"location":"enigma_machine/#class-methods","title":"Class methods","text":""},{"location":"enigma_machine/#enigmamachinerandom_configurationnof_rotorsnone-reset_after_cipheringtrue-include_digitsfalse","title":"<code>EnigmaMachine.random_configuration(nof_rotors=None, reset_after_ciphering=True, include_digits=False)</code>","text":"<p>Initializes the machine and all its components with a random configuration.</p> <p>Parameters</p> <ul> <li>nof_rotors <code>int</code>, optional:Number of rotors that compose the machine. If not specified, a randon number of them between 2 and 10 will be configured.</li> <li>reset_after_ciphering <code>bool</code>, default = True:Flag that controls if the machine should reset to the initial configuration after ciphering a text.</li> <li>include_digits <code>bool</code>, default = False:If True, the EnigmaMachine will include the digits to be ciphered. As default, only letters are to be ciphered.</li> </ul> <p>Returns</p> <ul> <li><code>EnigmaMachine</code>:The instance initialized to a totally random configuration for all the elements.</li> </ul>"},{"location":"enigma_machine/#enigmamachinefrom_configurationconfiguration-reset_after_cipheringtrue","title":"<code>EnigmaMachine.from_configuration(configuration, reset_after_ciphering=True)</code>","text":"<p>Initializes the machine from a specified configuration.</p> <p>Parameters</p> <ul> <li>configuration <code>dict</code>:Mapping containing the machine configuration. It must be defined as the one returned in <code>EnigmaMachine.initial_config</code>.</li> <li>reset_after_ciphering <code>bool</code> (default = True):Flag that controls if the machine should reset to the initial configuration after ciphering a text.</li> </ul> <p>Returns</p> <ul> <li><code>EnigmaMachine</code>:The instance initialized to the specified configuration.</li> </ul>"},{"location":"enigma_machine/#enigmamachinefrom_configuration_fileinput_path-reset_after_cipheringtrue","title":"<code>EnigmaMachine.from_configuration_file(input_path, reset_after_ciphering=True)</code>","text":"<p>Initializes the machine from a .json configuration file. Configuration files from previous released versions are supported.</p> <p>Parameters</p> <ul> <li>input_path <code>str</code>:Path to the .json file containing the configuration.</li> <li>reset_after_ciphering <code>bool</code> (default = True):Flag that controls if the machine should reset to the initial configuration after ciphering a text.</li> </ul> <p>Returns</p> <ul> <li><code>EnigmaMachine</code>:The instance initialized to the specified configuration within the file.</li> </ul>"},{"location":"enigma_machine/#properties","title":"Properties","text":""},{"location":"enigma_machine/#enigmamachineinitial_configuration","title":"<code>EnigmaMachine.initial_configuration</code>","text":"<p>Returns</p> <ul> <li><code>dict</code>:Initial configuration as a dictionary with the keys 'plugboard', 'rotors', 'reflector' and 'alphanumeric'.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>First thing, import the package to your module:</p> <pre><code>from enigma_cipher import EnigmaMachine\n</code></pre> <p>With that, now you can create your own <code>EnigmaMachine</code> instance, specifying the plugboard, the rotors and the reflector. However, let's keep it simple. To quickly use it, let's do a random initialization:</p> <pre><code>cipher = EnigmaMachine.random_configuration()\n</code></pre> <p>Now the instance is ready to use. The only thing left is to feed it the text or texts to cipher.</p> <pre><code>text = cipher.cipher_text(\"Hello world!\")\nprint(text)\n# 'OQOAX LBGBU!'\n</code></pre> <p>The term 'cipher' means to put a message through a code.  Thus, the same machine can decode the message with the same command.</p> <pre><code>text = cipher.cipher_text(\"OQOAX LBGBU!\")\nprint(text)\n# 'HELLO WORLD!'\n</code></pre> <p>However, only machines with the same configuration can decode texts.  Otherwise, you would be encoding another encoded text.</p> <p>You might have encountered the case in which you followed this quick tutorial, and your results were totally different from the ones exposed here. That is totally normal, as your <code>EnigmaMachine</code> would have a different configuration.</p> <p><code>EnigmaCipher</code> also allows you to initialize your machine from a given configuration saved in a .json file, or export your configuration so later on other machine can decode the texts that were previously encoded.</p> <pre><code># Export a configuration to a .json file\ncipher.export_configuration_to_json_file(\"enigma_config.json\")\n\n# Initialize a machine from a configuration file\ncipher = EnigmaMachine.from_configuration_file(\"enigma_config.json\")\n</code></pre> <p>If you want to check everything is correct, you can download this configuration file and initialize your machine with it. Then, try to decode the following text:</p> <pre><code>ELGDZBZO! RRT BTA YQRV PJR NM DESXQF NVJZX CINME OAI ILWEPH ODEXUWB.\n</code></pre>"},{"location":"plug_board/","title":"<code>enigma_cipher.PlugBoard</code>","text":"<p>The <code>PlugBoard</code> provides the mapping of each letter to another one. ach letter can be mapped to another letter only once. Mapping the letter 'A' with the letter 'T' will block this combination, not allowing mapping the letter 'T' with any other letter.</p> <p>The <code>PlugBoard</code> class can be imported directly from the <code>enigma_cipher</code> package:</p> <pre><code>from enigma_cipher import PlugBoard\n</code></pre>"},{"location":"plug_board/#plugboardplugged_keysnone-include_digitsfalse","title":"<code>PlugBoard(plugged_keys=None, include_digits=False)</code>","text":"<p>Initializes the <code>PlugBoard</code> from the given mapping of keys. It only takes alphabetic characters.</p> <p>Parameters</p> <ul> <li>plugged_keys <code>Mapping[str, str]</code>, optional: Mapping for every single letter in pairs. It is not necessary to specify both directions as {\"A\": \"B\", \"B\": \"A\"}; the specification of {\"A\": \"B\", ...} is enough for the class to understand the connection is bidirectional. Any not specified letter is assumed as one without any connection to another letter. If not specified, all letters are plugged to themselves.</li> <li>include_digits <code>bool</code>, default = False:If True, the PlugBoard will include the digits to be ciphered. As default, only letters are to be ciphered.</li> </ul>"},{"location":"plug_board/#plugboardcipher_charactercharacter","title":"<code>PlugBoard.cipher_character(character)</code>","text":"<p>Parameters</p> <ul> <li>character <code>str</code>:Letter to cipher through the component.</li> </ul> <p>Returns</p> <ul> <li><code>str</code>:The character ciphered only through the <code>PlugBoard</code>.</li> </ul>"},{"location":"plug_board/#class-methods","title":"Class methods","text":""},{"location":"plug_board/#plugboardrandom_mapinclude_digitsfalse","title":"<code>PlugBoard.random_map(include_digits=False)</code>","text":"<p>Initializes the PlugBoard class with a random mapping.  The mapping might contain all characters connected or only a few.</p> <p>Parameters</p> <p>include_digits: <code>bool</code>, default = False: If True, the PlugBoard will include the digits to be ciphered. As default, only letters are to be ciphered.</p> <p>Returns</p> <ul> <li><code>PlugBoard</code>:Initializes the PlugBoard class with a random mapping among the characters.</li> </ul>"},{"location":"plug_board/#properties","title":"Properties","text":""},{"location":"plug_board/#plugboardplugged_keys","title":"<code>PlugBoard.plugged_keys</code>","text":"<p>Returns</p> <ul> <li><code>Mapping[str, str]</code>:Configured keys mapping for all valid characters.</li> </ul>"},{"location":"plug_board/#plugboardcontains_digits","title":"<code>PlugBoard.contains_digits</code>","text":"<p>Returns</p> <ul> <li><code>bool</code>:Whether if the component contains digits within its valid characters</li> </ul>"},{"location":"reflector/","title":"Reflector","text":"<p>The reflector connects, in pairs, all the positions of the letters. This allows that an encoded text could be decoded with a machine having the same PlugBoard and Rotors configuration.</p> <p>The <code>Reflector</code> class can be imported directly from the <code>enigma_cipher</code> package:</p> <pre><code>from enigma_cipher import Reflector\n</code></pre>"},{"location":"reflector/#reflectormodehistorical-custom_mapnone-include_digitsfalse","title":"<code>Reflector(mode=\"historical\", custom_map=None, include_digits=False)</code>","text":"<p>Initializes the reflector instance.</p> <p>Parameters</p> <ul> <li>mode <code>Literal str</code>:String defining the mapping of the reflector. The choices are: <code>'historical'</code> (default): The historical reflector (the one used at the original machine) is set. <code>'random'</code>: The map among the letters is totally random. <code>'custom'</code>: Allows setting a specific reflector configuration.</li> <li>custom_map <code>dict</code>:Mapping of all characters. The mapping is only needed if <code>mode='custom'</code> is chosen. The characters must be specified in uppercase, and each character must be paired to only one another character. It supports having digits as characters to be ciphered.</li> <li>include_digits <code>bool</code>, default = False:If True, the Reflector will include the digits to be ciphered. As default, only letters are to be ciphered. This value is only considered for 'random' mode, as its value is computed for 'custom' mode and set to False for 'historical' mode.</li> </ul>"},{"location":"reflector/#reflectorreflect_charactercharacter","title":"<code>Reflector.reflect_character(character)</code>","text":"<p>Returns the reflection of a given character.</p> <p>Parameters</p> <ul> <li>character <code>str</code>:Character to be reflected.</li> </ul> <p>Returns</p> <ul> <li><code>str</code>:Reflection of the given letter.</li> </ul>"},{"location":"reflector/#properties","title":"Properties","text":""},{"location":"reflector/#reflectorreflections_map","title":"<code>Reflector.reflections_map</code>","text":"<p>Returns</p> <ul> <li><code>dict</code>:Map that composes the reflector</li> </ul>"},{"location":"reflector/#reflectoris_historical","title":"<code>Reflector.is_historical</code>","text":"<p>Returns</p> <ul> <li><code>bool</code>:Whether the current reflector is defined in the historical configuration.</li> </ul>"},{"location":"reflector/#reflectorcontains_digits","title":"<code>Reflector.contains_digits</code>","text":"<p>Returns</p> <ul> <li><code>bool</code>:Whether if the component contains digits within its valid characters</li> </ul>"},{"location":"rotor/","title":"Rotor","text":"<p>The <code>Rotor</code> provide a shift-ciphering based on the rotor's position. A rotor at position 0 will map a character with itself, for example, \"E\" = \"E\". A rotor at position 3 will map a character with the one three positions ahead, for example, \"E\" = \"H\".</p> <p>After ciphering a character, the first rotor will update its position in 1. The next rotors will update their position when the previous rotor has done a full spin.</p> <p>The <code>Rotor</code> class can be imported directly from the <code>enigma_cipher</code> package:</p> <pre><code>from enigma_cipher import Rotor\n</code></pre>"},{"location":"rotor/#rotorposition0-include_digitsfalse","title":"<code>Rotor(position=0, include_digits=False)</code>","text":"<p>Initializes the <code>Rotor</code> instance at the specified position.</p> <p>Parameters</p> <ul> <li>position <code>int</code>:Position in the range [0, 25] in which the rotor is initialized. Any given position higher than 25 is set to its equivalent within the range, for example, <code>position=32</code> is the same as <code>position=6</code>. If the position is not specified, the rotor is initialized at <code>position=0</code>.</li> <li>include_digits <code>bool</code>, default = False:If True, the Rotor will include the digits to be ciphered. This also affects the number of os positions the rotor can have. The index of the first digit (zero) is 26, meaning digits are sorted after letters. As default, only letters are to be ciphered.</li> </ul>"},{"location":"rotor/#rotorupdate_position","title":"<code>Rotor.update_position()</code>","text":"<p>Updates the rotor position in one unit, returning to position 0 when the last position is reached.</p>"},{"location":"rotor/#rotorcipher_charactercharacter-is_forward_path","title":"<code>Rotor.cipher_character(character, is_forward_path)</code>","text":"<p>Ciphers a single character through the current <code>Rotor</code> instance.</p> <p>Parameters</p> <ul> <li>character <code>str</code>:Character to be ciphered.</li> <li>is_forward_path <code>bool</code>:Evaluates if the path of ciphering is forward (from input to reflector) or backwards (from reflector to output).</li> </ul> <p>Returns</p> <ul> <li><code>str</code>:Ciphered character as the same or a new letter.</li> </ul>"},{"location":"rotor/#class-methods","title":"Class methods","text":""},{"location":"rotor/#rotorrandom_initinclude_digitsfalse","title":"<code>Rotor.random_init(include_digits=False)</code>","text":"<p>Parameters</p> <ul> <li>include_digits <code>bool</code>, default = False:If True, the Rotor will include the digits to be ciphered. This also affects the number of os positions the rotor can have. As default, only letters are to be ciphered.</li> </ul> <p>Returns</p> <ul> <li><code>Rotor</code>:Instance initialized in a position within the range [0, 25].</li> </ul>"},{"location":"rotor/#properties","title":"Properties","text":""},{"location":"rotor/#rotorcurrent_position","title":"<code>Rotor.current_position</code>","text":"<p>Returns</p> <ul> <li><code>int</code>:The current position of the rotor.</li> </ul>"},{"location":"rotor/#rotorcontains_digits","title":"<code>Rotor.contains_digits</code>","text":"<p>Returns</p> <ul> <li><code>bool</code>:Whether if the component contains digits within its valid characters</li> </ul>"}]}